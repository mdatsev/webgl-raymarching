
// sphere
float DE(vec3 p) {
    vec3 repeat_box = vec3(1, 1, 1);
    vec3 sphere_center = repeat_box / 2.;

    vmod(p, repeat_box);
    translate(p, -sphere_center);

    return (length(p.xyz) - 0.1);
}

// cube canonical
float DE(vec3 p) {
    vec3 a = abs(p.xyz) - 1.;
    return min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0));
}

// cube
float DE(vec3 p) {

    if (length(p) > 10.) {
        return 100.;
    }
    vec3 repeat_box = vec3(0.8, 0.8, 2);

    vec3 sphere_center = repeat_box / 2.;

    vmod(p, repeat_box);
    translate(p, -sphere_center);

    float s = 0.09;
    vec3 a = abs(p.xyz) - s;
    return (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0)));
}

vec3 calcNormal(vec3 p, float dx) {
    float eps = 0.00001;
    vec3 xDir = vec3(eps, 0, 0);
    vec3 yDir = vec3(0, eps, 0);
    vec3 zDir = vec3(0, 0, eps);

    return normalize(vec3(DE(p+xDir)-DE(p-xDir),
                DE(p+yDir)-DE(p-yDir),
                DE(p+zDir)-DE(p-zDir)));
}

// tetrahedron
float DE(vec3 p) {

    vec3 repeat_box = vec3(0.8, 0.8, 2);

    vec3 sphere_center = repeat_box / 2.;
    
    //rotY(p, uTime /1000.);
    //rotX(p, uTime /1000.);
    
    //translate(p, 0.1,0.1,0.1);
    
    float md = max(
        max(-p.x - p.y - p.z, p.x + p.y - p.z),
        max(-p.x + p.y + p.z, p.x - p.y + p.z)
    );
    return  (md - 0.2) / sqrt(3.);
}

// http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4264&rep=rep1&type=pdf
float DE(vec3 p0) {
    vec3 p1 = vec3(-1, -1, 0);
    vec3 p2 = vec3(1, 0, 0);
    vec3 p3 = vec3(0, 1, 0);

    vec3 p1p2 = p2 - p1;
    vec3 p1p3 = p3 - p1;
    vec3 p1p0 = p3 - p1;

    vec3 Np = cross(p1p2, p1p3);

    float cos_a = dot(p1p0, Np) / dot(normalize(p1p0) * normalize(Np));

    vec3 p0Pp = - 
}

// menger
float DE(vec3 p) {
    vec3 repeat_box = vec3(0.8, 0.8, 2);

    vec3 sphere_center = repeat_box / 2.;

    rotY(p, uTime);
    rotX(p, uTime);

    //vmod(p, repeat_box);
    //translate(p, -sphere_center);
    
    //p.x = p.x * 2.;
    //p.y = p.y * 2.;
    
    //p.x = p.x * 1.1;
    
    
    float s = 0.2;
    float m = 0.4;

    float scale = 3.;
    
    vec3 offsets[8];
    offsets[0] = vec3(m, 0., 0.);
    offsets[1] = vec3(m, m, 0.);
    offsets[2] = vec3(0., m, 0.);
    offsets[3] = vec3(-m, m, 0.);
    offsets[4] = vec3(-m, 0., 0.);
    offsets[5] = vec3(-m, -m, 0.);
    offsets[6] = vec3(0., -m, 0.);
    offsets[7] = vec3(m, -m, 0.);
    
    float totalscale = 1.;
    
    float dist;

    for (int i = 0; i < 7; i++) {
        dist = 99999999999.;
        vec3 o;
        for (int i = 0; i < 8; i++) {
            vec3 origp = p;
            
            float d = cube(translate(p, offsets[i]), s);
            if (d < dist) {
                o = offsets[i];
                dist = d;
            }
            
        }
        p = (p + o) * scale;
        totalscale *= scale;
    }

    return dist / totalscale;
}

//http://www.fractalforums.com/ifs-iterated-function-systems/revenge-of-the-half-eaten-menger-sponge/15/

// menger
float DE(vec3 pos) { //by recursively digging a box
    
    pos = pos + 0.5;
    float x=pos.x, y=pos.y, z=pos.z;

    float xx=abs(x-0.5)-0.5, yy=abs(y-0.5)-0.5, zz=abs(z-0.5)-0.5;
    
    float d1=max(xx,max(yy,zz)); //distance to the box
    float d=d1; //current computed distance
    float p=1.0;
    for (int i=0; i<=5; ++i) {
        float xa = mod(3.0*x*p,3.0);
        float ya = mod(3.0*y*p,3.0);
        float za = mod(3.0*z*p,3.0);
        p*=3.0;

        //we can also translate/rotate (xa,ya,za) without affecting the DE estimate

        float xx=0.5-abs(xa-1.5), yy=0.5-abs(ya-1.5), zz=0.5-abs(za-1.5);
        //d1=min(max(xx,zz),min(max(xx,yy),max(yy,zz))) / p; //distance inside the 3 axis-aligned square tubes
        d1 = max(min(xx,zz),max(min(xx,yy),min(yy,zz))) / p;
        d=max(d,d1); //intersection
    }
    //return d*2.0; //the distance estimate. The *2 is because of the scaling we did at the beginning of the function
    return d;
}
























void xfold(inout vec3 v) {
    if(v.x < 0.) {
        v.x = -v.x;
        v.xy *= 2.;
    }
}

void translatei(inout vec3 v, float x, float y, float z) {
    v += vec3(x, y, z);
}

void translatei(inout vec3 v, vec3 t) {
    v += t;
}

vec3 translate(inout vec3 v, float x, float y, float z) {
    return v + vec3(x, y, z);
}

vec3 translate(inout vec3 v, vec3 t) {
    return v + t;
}

void rotate(inout vec3 v, vec3 t) {
    v += t;
}

void rotX(inout vec3 z, float s, float c) {
    z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);
}
void rotY(inout vec3 z, float s, float c) {
    z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);
}
void rotZ(inout vec3 z, float s, float c) {
    z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);
}


void rotX(inout vec3 z, float a) {
    rotX(z, sin(a), cos(a));
}
void rotY(inout vec3 z, float a) {
    rotY(z, sin(a), cos(a));
}
void rotZ(inout vec3 z, float a) {
    rotZ(z, sin(a), cos(a));
}

void vmod(inout vec3 p, vec3 m) {
    p.x = mod(p.x, m.x);
    p.y = mod(p.y, m.y);
    p.z = mod(p.z, m.z);
}

float cube(vec3 p, float s) {
    vec3 a = abs(p);
    return max(max(a.x, a.y), a.z);
}

void umin(inout float mind, float d) {
    if (d < mind) {
        mind = d;
    }
}

float m1(inout vec3 p) {

    float s = 0.1;
    float m = 0.21;
    float md = 999999999999999999999999999.;

    translate(p, m, 0., 0.);
    umin(md, cube(p, s));

    translate(p, 0., m, 0.);
    umin(md, cube(p, s));
    
    translate(p, -m, 0., 0.);
    umin(md, cube(p, s));
    
    translate(p, -m, 0., 0.);
    umin(md, cube(p, s));

    translate(p, m, -m, 0.);

    return md;
}

void flipXY(inout vec3 p) {
    p.xy = -p.xy;
}



/ my menger 2
float DE(vec3 p) {
    float scale = 3.;
    float totalscale = 1.;
    float dist;

    for (int i = 0; i < 3; i++) {
        dist = INF;
        dist = mengerIteration(p);
        float xc = clamp(
            floor((p.x + 1.5 * THIRD) * 3.) / 3. - 1.5 * THIRD + 0.5 * THIRD,
            -THIRD,
            THIRD
        );

        float yc = clamp(
            floor((p.y + 1.5 * THIRD) * 3.) / 3. - 1.5 * THIRD + 0.5 * THIRD,
            -THIRD,
            THIRD
        );

        float zc = clamp(
            floor((p.z + 1.5 * THIRD) * 3.) / 3. - 1.5 * THIRD + 0.5 * THIRD,
            -THIRD,
            THIRD
        );

        float a=0., b=0., c=0.;
        if (abs(p.x) > 0.5 * THIRD && abs(p.y) > 0.5 * THIRD && abs(p.z) > 0.5 * THIRD) {
            a = THIRD;
            b = THIRD;
            c = THIRD;
        } else if (abs(p.x) > 0.5 * THIRD || abs(p.y) > 0.5 * THIRD || abs(p.z) > 0.5 * THIRD) {
            if (abs(p.x) > 0.5 * THIRD || abs(p.y) > 0.5 * THIRD)
            if (abs(p.z) > 0.5 * THIRD) {
                c = THIRD;
                if (abs(p.x) > 0.5 * THIRD && abs(p.y) > 0.5 * THIRD) {
                    a = THIRD;
                    b = THIRD;
                } else if (abs(p.x) > 0.5 * THIRD || abs(p.y) > 0.5 * THIRD) {
                    a = xc;
                    b = yc;
                } else if (abs(p.x) > abs(p.y)) {
                    a = THIRD;
                    b = 0.;
                } else if (abs(p.y) > abs(p.x)) {
                    a = 0.;
                    b = THIRD;
                }
            }
            if (abs(p.y) > 0.5 * THIRD) {
                b = THIRD;
                if (abs(p.x) > 0.5 * THIRD && abs(p.z) > 0.5 * THIRD) {
                    a = THIRD;
                    c = THIRD;
                } else if (abs(p.x) > 0.5 * THIRD || abs(p.z) > 0.5 * THIRD) {
                    a = xc;
                    c = yc;
                } else if (abs(p.x) > abs(p.z)) {
                    a = THIRD;
                    c = 0.;
                } else if (abs(p.z) > abs(p.x)) {
                    a = 0.;
                    c = THIRD;
                }
            } else if (abs(p.x) > 0.5 * THIRD) {
                b = yc;
                c = zc;
            }
        } else if (abs(p.x) > abs(p.y) && abs(p.x) > abs(p.z)) {
            a = THIRD;
            b = 0.;
            c = 0.;
        } else if (abs(p.y) > abs(p.x) && abs(p.y) > abs(p.z)) {
            a = 0.;
            b = THIRD;
            c = 0.;
        } else if (abs(p.z) > abs(p.y) && abs(p.z) > abs(p.x)) {
            a = 0.;
            b = 0.;
            c = THIRD;
        }

        a *= sign(p.x);
        b *= sign(p.y);
        c *= sign(p.z);


        vec3 o = vec3(a, b, c);//floor((p + 1.5 * THIRD) * 3.) / 3. - 1.5 * THIRD + 0.5 * THIRD;

        p = (p - o) * scale;
        totalscale *= scale;
    }
    return dist / totalscale;
}